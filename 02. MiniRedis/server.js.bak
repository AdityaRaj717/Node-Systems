import net from 'node:net'

const redisStorage = new Map();

const server = net.createServer((server) => {
  console.log('Client connected')
})

// Buffering
let buffer = ""
server.on('data', (chunk) => {

  buffer += chunk.toString('utf8')

  if (buffer.length > 8000) {
    server.end()
    return
  }

  // To handle message fragmentation
  while (buffer.includes('\r\n')) {

    // PING
    // ECHO "value"
    // GET {key} {value}
    // SET {key} {value}

    const index = buffer.indexOf('\r\n')
    const message = buffer.slice(0, index).trim().split(/\s+/)
    buffer = buffer.slice(index + 2)

    // const command = message[0].toUpperCase()
    //
    // const parsedObject = {
    //   command: command,
    //   key: undefined,
    //   value: undefined,
    //   options: {
    //     EX: undefined,
    //   }
    // }
    //
    // const response = handleCommand(message, parsedObject)
    // socket.write(response)

    server.write("Hello\r\n")
  }
})

server.on('end', () => {
  console.log('Client disconnected')
})

server.on('error', () => {
  console.log('Client has forcefully exited.')
})

const PORT = 6379
server.listen(PORT, () => {
  console.log(`Server has started listening on ${PORT}...`)
})

// const commands = {
//   "PING": handlePING,
//   "SET": handleSET,
//   "GET": handleGET,
// }
//
// function handleCommand(message, parsedObject) {
//
//   const allowedOptions = ["EX"]
//
//   // const parsedObject = {
//   //   command: command (done),
//   //   key: key,
//   //   value: value,
//   //   options: {
//   //     EX: undefined,
//   //   }
//   // }
//
//   if (parsedObject.command === "PING") {
//     return '+PONG\r\n'
//   }
//
//   else if (parsedString.command === "ECHO")) {
//     optionHandler()
//     const echoString = parsedString.split("ECHO ")
//     if (echoString[1] !== undefined) {
//       return `+${echoString[1]}\r\n`
//     }
//     else return "+ \r\n"
//   }
//
//   else if (parsedString.startsWith("SET")) {
//     const setArguments = parsedString.split(" ")
//
//     if (setArguments[3] !== undefined && setArguments[3].toUpperCase() === 'EX') {
//       const deathTime = Date.now() + (setArguments[4] * 1000)
//       redisStorage.set(setArguments[1], { value: setArguments[2], expiresAt: deathTime })
//     }
//
//     else redisStorage.set(setArguments[1], { value: setArguments[2] })
//     return '+OK\r\n'
//   }
//
//   else if (parsedString.startsWith("GET")) {
//     const getArguments = parsedString.split(" ")
//     const searchKey = getArguments[1]
//
//     if (redisStorage.has(searchKey)) {
//       const searchKeyValue = redisStorage.get(searchKey)
//       if (searchKeyValue.expiresAt !== undefined && searchKeyValue.expiresAt > Date.now()) {
//         return `+${searchKeyValue.value}\r\n`
//       }
//       else if (searchKeyValue.expiresAt !== undefined && searchKeyValue.expiresAt < Date.now()) {
//         redisStorage.delete(searchKey)
//         return `$-1\r\n`
//       }
//       else return `+${searchKeyValue.value}\r\n`
//     }
//
//     // RESP standard for "Null/Nil
//     else return '$-1\r\n'
//   }
// }
//
// function optionHandler(message, allowedOptions, parsedObject) {
//
//   // PING
//   // ECHO "value"
//   // GET {key} {value}
//   // SET {key} {value}
//
//   // const parsedObject = {
//   //   command: command (done),
//   //   key: key,
//   //   value: value,
//   //   options: {
//   //     EX: undefined,
//   //   }
//   // }
//
//   let optionIndex = -1;
//
//   for (let i = 2; i < message.length; i++) {
//     if (allowedOptions.includes(message[i].toUpperCase())) {
//       optionIndex = i
//       break;
//     }
//   }
//
//   const key = message[1]
//   const value = optionIndex !== -1 ? message.slice(2, optionIndex).join(' ') : message.slice(2).join(' ')
//
//
//
//   // Options handling
//   if (optionIndex !== -1) {
//     for (let i = optionIndex; i < message.length; i += 2) {
//       switch (message[i].toUpperCase()) {
//         case "EX":
//           if (isNan(message[i + 1])) {
//             socket.write('Invalid value for option EX. Please enter a valid integer')
//             return
//           }
//           else if (message[i + 1] === undefined) {
//             socket.write('Please provide a value for option EX')
//             return
//           }
//           parsedObject.options.EX = message[i + 1]
//           break
//
//         default:
//           socket.write(`The entered option ${message[i]} does not exist. Enter a valid option`)
//           return
//       }
//     }
//   }
// }
//
//
// function handlePING() { }
// function handleSET() { }
// function handleGET() { }
